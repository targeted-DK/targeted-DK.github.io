---
layout: post
title: "Temporal Capabilities : Access Control For Time"
date: 2024-12-22
categories: Systems Scheduling
---

# III. TCap System Model and Design
Tcaps와 여러 하위 시스템과 스레드 실행의 관계를 이해하기 위해 간단한 모델을 제시함. 시스템은 다수의 하위 시스템으로 구성되어 있으며, $s^{x} \in S$, 각 하위 시스템은 전체 시스템의 principals라고 지칭한다.(시간 소비자들). 각 하위 시스템의 스케쥴러는 그 하위 시스템에 존재하는 모든 스레드가 필요로하는 연산 자원을 정리하는데 책임을 가지고 있으며, 모든 하위시스템은 이러한 스케쥴링 서비스를 가지고 있다. 예시로는 가상 머신이나. hierarchial scheduling systems. 분리된 커널 등이 있다. Tcap의 경우 항상 모든 시간에 활성화 되어야 하며, 모든 processing time(처리 시간)은 활성화된 TCap과 연결됨. 각 스레드의 실행은 동적으로 TCap과 관련되어 있다. 각 하위 시스템 ($s^{x}$)는 TCap 세트에 capabtility가 통제된 접근을 가지고 있다. $T^{x} = {t_{1}^{x} ...}$

## TCaps Budget

각 Tcap은 $t_{n}^{x}$는 한도(budget)을 가지고 있으며, 이는 시간을 스칼라 값으로 나누어 하위 시스템에 cycles(주기) 할당한다. 이 한도는 스레드 실행에서 사영된다. Delegation(양도)는 한 개의 TCap에서 다른 비동기적인 종점 객체(다른 하위시스템)에 시간을 건네주는 역할을 한다. 예를들어, b 단위시간을 $t_{n}^{x}$에서 $t_{m}^{y}$을 양도할시, 주어진 한도는 아래와 같이 계산된다.
$B_{n}^{x} = B_{n}^{x} - b$ \\

$B_{m}^{y} = B_{m}^{y} + b$.
즉 각 TCap의 시간은 시스템이 제공하는것이 아니라 다른 TCap이 반드시 양도해야 한다.

TCap 중에서 Chronos($t^{c}$)라고 부르는 tcap이 존재하는데, 이는 우리가 신뢰할 수 있는 하위 시스템 $s^{c}$에서 $B^{c} = \infty$를 가진다. 다른 모든 TCaps 들이 한도를 모두 사용하였을때, $t^{c}$가 활성화 되면서 한도를 양도해 채우게 된다. 이 채우는 과정은 프로그램에 따라 시간에 맞춰 달라질 수 있다.

## TCaps Quality
각 TCap은 $Q_{n}^{x}$라는 quality를 가지고 있다. 이는 각 Tcap이 가지고 있는 시간의 중요성을 나타내는 지표이다. $Q_{n}^{x}$ = $p_{n}^{x}$, $Q_{n}^{y}$. 각 하위 시스템의 Tcap에 스칼라 값의 중요도를 각 시스템이 보유한 semantics를 활용하여 할당한다. 각 TCap의 quality는 각 하위시스템의 중요도에 맞춰 할당된 한도 $t_{n}^{x}$를 포함한다. 낮은 $p_{n}^{x}$ 값은 높은 quality를 의미한다.
TCap에서 높은 퀄리티는 선제 결정(preemption decisions)를 만들기 위해 사용된다. 비동기 이벤트(비동기 전송 또는 중단)가 $t_{n}^{x}$를 활성화하여 현재 스레드에  $t_{n}^{y}$을 이용하여 선제적으로 실행해야하는지 결정하며 이는  $Q_{n}^{x} > Q_{m}^{y}$인 경우에만 해당한다. Quality는 모든 시점에서 어떤 TCap을 실행해야하는지 결정하는게 아니며 스케쥴 결정을 내리기 위함이 아니다. 그래서 TCaps의 순서를 정의하기 위해 사용되지 않는다. 
![](/images/TCaps/3.png)

여기서 $Q_{n} > Q_{m}$ 또는  $Q_{m} > Q_{n}$ 둘 다 가능하지 않다. 이런 경우엔 두 개의 스케쥴러가 한 개의 TCap과 관련해 상대적 시간의 중요성에 대해 동의하지 않는 경우이다. TCap의 근본적인 목적은 local 우선도의 양도가 로컬 스레드에 할당된 한도를 방해하지 않는 것이다. 그래서 선제성은 모든 스케쥴러가 선제성이 필요하다고 동의할 경우 부여된다. 

잘못된 양도로 인한 방해를 방지하기 위해 quality의 양도는 각 하위 시스템에서 덜 우선시 되게 고안되었다. 
![](/images/TCaps/4.png)

위 공식에서는 하위 시스템에서 특정 스케쥴러의 시간적 우선도가 유지되며 transitive delegation(전이적 위임)에서 선제적 결정을 위해 사용된다. 이는 분산정보 흐름에서 label이 관리되는 형식과 비슷하다. 위 두 공식을 사용하여 중요한 TCap 성질을 알 수 있는데 이는, 로컬 하위 시스템 우선도가 전역적(global)인 선제 결정에 영향을 준다. 

## TCap Usage Example

![](/images/TCaps/2.png)
위 사진에서는 4개의 하위 시스템으로 구성된 간단한 시스템을 구현하였으며 간단한 양도 패턴이 사용된다. (a)에서는 부모에서 자식으로 양도되는 과정을 보여주며, (b)에서는 자식간 양도를 보여준다. ($s^{m}$에서 $s^{h}$으로 I/O 요청). (a)에서, 1) $s^{m}$은 $s^{p}$과 $s^{h}$ 낮은 우선도가 부여됨(높은 숫자). 이는 비동기 전송이 $s^{h}$ 실행에 있어 방해하지 않을 것임을 알 수 있다. ($t_{0}^{m} /> t^{h}$). 2) 위 표에서 표현된 interrupt(방해)를 통해 $t_{1}^{m}$과 관련된 실행을 활성화하는 것은 선제적인 결정을 일으키지 않을 것이다. ($B_{1}^{m}$). 3) 이러한 양도가 $T = M + N + L$ 주기마다 일어난다며, 하위 시스템의 사용률은 다음과 같다. $s^{h} : M/T$, $s^{l} : L/T$.
(b)부분에서 자식간 양도가 이루어 진 것을 볼 수 있는데. 이는 $s^{h}$가 $t_{1}^{m}$에 m 주기만큼 양도하여 I/O처리에 사용할 수 있도록 하였고, $t_{1}^{m}$ ($t_{1}^{m}$ > $t_{0}^{m}$), $s^{h}$ 관련된 interrupt(중단)은 $s^{m}$의 모든 실행보다 우선될 것이며,$s^{h}$의 모든 실행보다 우선될 것임($t_{0}^{m}$ > $t^{h}$). 하지만 $s^{p}$에서는 우선시 되지 않음($t_{1}^{m}$ > $t^{p}$). 자식 간 양도에서 볼 수 있듯이 $s^{m}$은 $s^{h}$의 실행을 m 주기 동안 preempt 될 수 있다. 이는 매우 중요한데, 이는 전통적으로 우선순위를 매길 때((a) 참고) $s^{m}$는 $s^{h}$보다 먼저 실행되지 않기 때문이다. $s^{h}$는 interference를 제한하여 $s^{m}$가 자신 만의 스레들을 소유하여 IO 요청을 처리를 만족시키기 위해 m을 조심히 선택하게 한다. 물론 이 어떤 $s^{p}$, $s^{h}$, $s^{m}$, $s^{l}$은 양도와 우선순위 재조정을 통해 $t_{1}^{m}$이 자신들의 스레드를 preempt하는 과정을 막을 수 잇으며, 이는 각 하위 시스템이 양도를 통해 확정된 시간의 실행을 다른 하위시스템의 실행 시간과 효율적으로 통합시킨다. 

이 예시는 TCaps가 하위 시스템간 미세한 조율을 할 수 있음을 보여주면서도 로컬 스케쥴러가 중단되는 경우를 제한하여 유지될 수 있도록 한다. (b)에서 $s^{p}$가 특별히 양도에 관련되어 있지는 않지만,  $s^{p}$의 시간 제약에 따르면 T 주기마다 우선도 1이 M 주기마다 실행된다. 

(c)를 통해서 양도가 어떤식으로 영향을 미치는지 알 수 있다. 자식간 양도는 시간의 퀄리티를 낮추게 된다. 예를 들어 $s^{l}$부터 $t_{1}^{m}$로의 양도는 $t_{1}^{m}$의 퀄리티를 $n = m + 1$으로 낮춘다.  $s^{l}$은 l 주기만큼 낮추어 $t_{1}^{m}$이 $s^{l}$를 preempt할 수 없도록 한다. $s^{l}$에서의  $s^{p}$ 우선도는 모든 TCaps에서 낮으며, 이 양도로 인해 $t_{1}^{m}$는 낮은 우선도를 상속받게 된다. 이것으로 인해, $s^{m}$을 포함하며 모든 하위 시스템을 preempt할 수 없게 된다. 모든 시간에 있어서(n) 퀄리티의 하락은($s^{l}$에서 파생됐지 않더라도) TCaps의 설계를 알 수 있다. 퀄리티는 perssimistic 하지만 양도하는 하위시스템은 양도받은 시간의 interference(간섭)의 상한치를 보장한다. 하지만 여러 다른 하위 시스템의 양도는 TCap의 전체적인 퀄리티를 부정적으로 영향을 준다. 그렇기 때문에 시스템에 대한 중요한 설계 제약은 이 부분이 바람직 하지 않아야 한다. (예를 들어, I/O 요청관련 다른 하위시스템관 분리 요구의 필요성) 이는 다른 TCaps를 사용하여 다른 하위시스템으로 부터 양도 받는 것이다. 결론은 TCaps는 매우 보호적인 매개를 통해 단단히 paired되어 있으며 이는 주어진 하위 시스템의 어떤 TCaps가 양도에 대한 권한을 통제한다. 
TCaps는 접근 통제 레이어이며 이는 모든 스케쥴링 연산과 비동기 통신을 중재한다. TCaps는 근본적으로 하위시스템 내의 연산 시간 할당과 시간의 소비를 분리시킨다. 이런 분리 작업은 전체 시스템의 스케쥴링 약속을 공고히 하며 각 스케쥴링에 미세한 통제를 가능케 한다. 각 하위시스템의 연산량을 제한하여 isolation을 제공하며 각 하위시스템이 언제 시간적 딜레이(preemptions)를 유발시킬 수 있는지 제한한다. 

## TCaps Examples and guarantees
![](/images/TCaps/5.png)

Tcaps는 여러 하위 시스템 간의 협력과 통제에 중점을 두어 하위시스템간에 여러 관계를 생성해 낸다. 양도 패턴은 시스템간의 시간 흐름을 결정하고 이는 설계 중점과 장단점을 제공한다. 예를 들어, 각 하위시스템에 양도된 한도는 varying levels of assurance를 생성하며, 양도의 우선순위와 granularity는 양도를 받는 하위시스템의 간섭에 영향을 주며, 하위시스템이 스레드를 관리하고 간섭하는 부분에 있어 activation latency에 매우 큰 영향을 준다. 위사진에서 두 가상 머신이 각각 여러개의 어플리케이션을 가지고 있는데, 각 어플리케이션은 가상머신과 글로벌 스케쥴러에 동일한 레벨에 위치해 있다. 두번째 가상머신은 첫번째 가상머신으로 부터 시간 양도를 전달받는다. Chronos가 글로벌 스케쥴러와 첫번째 가상머신으로 시간을 주입한다. 

**Global Scheduling** 
일반적인 시스템은 커널 스케쥴러를 가장 하나의 하위시스템을 통해 시스템 시간을 조정한다. 비슷하게, 글로벌 시스템 스케쥴러가 하위 시스템으로의 양도의 통제 전이를 조정한다. (위 사진 참조).

**Separation Kernel**
분리 커널은 자원을 나누어서 하위시스템간 강력한 독립을 제공하고 Tursted Computing Base에 대한 의존을 최소화 한다. 이는 정보 흐름을 강력하게 통제하여 공격 여지를 매우 제한하며, 강력한 tmporal isolation을 제공한다. TCaps는 $s^{c}$가 용하여 static한 cyclic executive을모방할수 있고 이는 table-driven schedule이다.  $s^{c}$가  $t_{c}$에서 각 하위시스템으로 양도하며 마지막에 통제 또한 옮긴다. 하위시스템의 교체는 한도가 사용되었을 경우 일어나며, 다음 하위시스템을 trigger한다.  $s^{c}$는 모든 한도가 사용되었을때 활성화 된다(크로노스의 한도는 무한하므로). 기기들은 여러 하위시스템으로 분리되어있으며 간섭 스레드는 우선권이 주어지는데 이는  $s^{c}$에서 양도받아 그 어떤 하위시스템도 다른 시스템을 preempt할 수 없게 한다. 


![](/images/TCaps/6.png)

위 사진에서 $s^{c}$으로부터 두 개의 하위시스템으로 3/1000초 와 5/1000초를 양도하는 코드이다. 각 하위 시스템은 매 8/1000초마다 3/1000초와 5/1000초의 실행을 보장받으며 각 시스템의 우선도는 서로가 preempt하지 않음을 보장한다. 분리 커널 철학에 따라 적은 trsuted code를 통해
두 하위시스템간의 미세한 스케쥴링을 완전히 배제하여 강력한 분리시킨다. 

**Hierarchical Scheduling**
Hierarchical 스케쥴링 시스템(HSS)은 하위시스템간 부모-자식 관계를 형성한다. 주어진 부모 하위시스템은 자식 하위시스템에 적절히 양도하고 활성화 시킨다. 이런 양도는 한 개의 단위시간을 양도하여 부모가 각 하위시스템의 시간 단위의 범위를 완전히 통제할 수 있도록 한다. 각 자식은 다른 자식의 부모가 될수 있으며 이는 위 표를 통해 알 수 있다. 만약 자식 하위시스템이 idle하다면 나머지 시간을 부모에게 다시 재양도 할 수 있다.

**Virtual Machines**
가상머신은 HSS 인스턴스에 사용되지 않지만 같은 기술이 사용된다. 하지만 실용적인 VM 시스템은 VM간에 dependencies를 만든다. 예를들어 Dom0은 신뢰할 수 있는 VM이며 다중 I/O를 담당한다. 이는 다른 VM들로부터 비동기 서비스 요청을 받는다. TCaps는 가성 머신들이 가성 기기 드라이버를 통해 Dom0으로 기능적 요청을 할 수 있도록하며 요청을 처리하기 위해 시간을 양도할 수 있다. VM을 대신하여 Dom0의 실행은 그 VM의 시간으로 실행되며 이는 비동기 실행이 가능할 수 있도록한다. 위 표에 따르면 시스템 스케쥴러는 가상머신에게 시간을 제공하고 이는 가성머신이 요청을 만들고 TCaps를 제공하여 IO요청을 할 수 있도록한다. 

**Generality across scheduling policies** 
스케쥴링 정책은 사용자 레벨에서 정해지며 이는 임의의 스케쥴링 정책을 허용한다. 하지만 하위 시스템간의 비동기 활성하와 하위시스템에 부여된 간섭은 TCap 우선도를 사용한다. 이  우선도는 하나의 스캘라 값이고 이를 위해 64 비트 무부호 정수를 사용한다. TCaps는 pairwise 스케쥴링 결정을 한개의 큰 1차원적의 namespace로 압축할 수 있는 스케쥴링 정책을 지원한다. 고정된 우선도 스케쥴러들은 이 constraint를 만족하며 UNIX의 시간 공유 스케쥴러들은 스레드의 우선도를 nice한 값들로 선형화한다. 동적 스케쥴링 우선도같은 경우(Earliest Deadline First) 우선도 값을 타임라인으로 사용하여 각 스레드의 우선도를 타임라인의 마감시간으로 설정한다. 이는 event-triggered 동적 스케쥴링 정책을 가능케 한다. 

## Capability-Based OS Integration
Fiasco.OC와 seL4와 같은 현대 u-kernel 시스템은 capabtiliy-based access control를 통해 시스템 자원의 접근을 보호한다. 접근 통제 정책은 어떤 작업들이 각 시스템의 자원에 수행될 수 있는지 정의한다. 이러한 u-kernel의 capability 시스템은 메모리, 실행, 간섭의 추상화에 집중되어있으며, 고정된 스케쥴링 정책의 매개변수화를 통해 시간 조정을 다룬다. 이를 통해 스케쥴링 정책을 global fixed priority namespace로 매핑한다. 
우리는 TCaps를 Composite component-based OS에 도입하였다. Composite의 경우 capability-based kernel API로 접근이 가능한 간단한 추상화로 구성되어 있다. Capabilities는 지울 수 없는 토큰이며 이들의 소유권은 특정 작업들이 시스템 자원에서 수행될 수 있음을 의미한다. Components는 사용자 레벨에서 실행을 호스트하며 이는 capability table과 page-table의 collection이다. 모든 시스템 자원은 이 table을 통해 접근할 수 있으며 이는 components가 분리 단위와 자원에 대한 접근 범위를 제한한다. Capabilities를 통해 접근할 수 잇는 커널 자원들은 TCaps, components, threads, invocation end-points와 비동기 coordination end-points 이다. 
Composite 커널 같은 경우 스케쥴러를 가지고 있지 않다. 그대신 시스템이 사용자 레벨의 component-based 스케쥴러를 사용하며 이는 스레드와 간섭 스케쥴링에 사용된다. 또한 TCaps도 사용한다. 사용자 레벨의 스케쥴링을 부여하기 위해 커널은 thread에 대한 capability를 보유한 스케쥴러를 통해
