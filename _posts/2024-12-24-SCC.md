---
layout: post
title: "Scheduling-Context Capabilities"
date: 2024-12-24
categories: Systems Scheduling
---

# Introduction

Cyber-physical 시스템은 강력한 termporal requirements를 가지고 있는데 이는 OS에서 지원되지 않는 부분이다. OS의 경우 우선도와 시간 민감도, 중요성을 융합한다.
사용되는 분야에 따라 temporal protection이 필요하다. 
AAV야 말로 mixed-criticality system(MCS)의 예시이다. 이는 공간, 무게, 전력을 줄여야한다는 비행학의 개념이다. safety-critical 시스템에서는 어떤 component의 작업 수행이 덜 중요한 component로부터 영향 받지 않아야 한다. 
시스템은 결국 공간 및 시간적으로 직교하여 분리되어 있다.

Integrity property는 데드라인은 반드시 준수되어야 한다는 규칙이다. Worst-case execution time(WCET)이 수행될 수 있는 시간이 항상 존재하여야 함. 
스케쥴 분석에 따르면 overcommitted system이란 모든 것들이 항상 스케쥴 되지 않을 수 있다는 것이다.
MCS의 경우 시간적 분리를 위한 OS 지원이 필요하며 이는 상위 우선도(낮은 임계) 스레드가 높은 임계 스래드를 preempt할 수 있지만 프로세서 전체를 독점할 수는 없다. 
그래서 이 논문에서는 다음을 다룬다.
1. capability 시스템은 낮은 overhead를 발생시킨다.
2. cpu-time 한도라는 개념은 빠른 ipc 도입을 위해 호환이되며 이는 전통적으로 고성능 microkernels에 사용된다. 그리고 실시간 자원 공유 정책과 호환이 가능하다.
3. preempt가 불가능한 seL4 microkernel에 대한 설명과 사용자 레벨에서 커널 메모리는 다룰 수 있는 커널 모델에 대한 설명. 이는 강력한 공간 분리를 위해 사용됨
4. 커널의 static policies위에 사용자 레벨 스케쥴러 안에 동적 우선도 시스템을 도입함. 이는 임의의 스케쥴링 정책이 적은 overhead로 도입될 수 있음을 보여줌.


# Background
## Real Time Theory Basics
표준 실시간 이론은 task라는 용어를 사용하는데 이는 OS의 스레드라는 개념을 매핑한다. 이는 주기적으로 스레들을 실행하는 것을 의미하는데, 이는 일반적은 통제 시스템에 매핑됨을 의미한다.
비주기성 스레드는 최소 도달 시간이라는 개념을 장착한 모델을 사용하여 간섭 한도를 최대화하고 이는 스레드의 주기동안 스케쥴 분석에 사용된다. RT(실시간) 이론은 데드라인이 있으며 이는 반드시 연산이 끝나야하는 시간이며 이는
explicit 또는 implicit할 수 있다.
우선도는 고정이거나 동적일 수 있다. 가장 합당한 고정 방식은 rate-monotonic priority assignment(RMPA)이며 이는 주기의 역인 rate가 우선도가 된다. Total utilization이 log2이하일 경우 스케쥴성을 보장할 수 있다. 
가장 합당한 정책은 earlist-deadline first(EDF)이며 이는 동적 우선도 정책으로 가장 데드라인이 가까운 스레드를 선택한다. 
스케쥴 한도를 넘는 건 overcommited / overloaded된다고 표현한다. 

## Criticality, time-sensitivity and trust
Criticality는 전체 시스템 목적에 근거하여 각 component의 중요성을 의미한다. 
Time sensitivity의 경우 스레드가 특정 시간에 프로세서에 접근하기 위해 얼마나 중요한지를 의미한다.
Trust의 경우 어떤 component가 올바르게 작동하기 위해 필요한 의존성을 의미한다. 

## Capabilities to time
Capabilites는 공간적 자원의 접근 통제권에 대해 미세하게 조정된 방식이다. 
시간의 경우 임의로 나눌수 있지만 변화시킬수 없다. 시간에 대한 capabilities는 공간 자원과는 달리 다르게 사용된다. 이는 hierarchial delegation을 손실 없이 지언할수 없고 또한 가상화 시킬수 없다. 양도가 공간 기능의 좋은 이점이지만 그렇다고 양도가 성격을 규정하지 않으며 이는 prima facie evidence of access privilege임을 알 수 있다. 

## Resource Sharing
주요 요소들의 integrity는 스레드 간의 통신에 매우 중요하다. 가장 기본적인 방법은 공유 데이터와 코드를 캡슐화하여 싱글 스레드 리소스 서버변화시키는 것이다. 만약 공유 서버가 다른 우선도를 가진 여러 클라이언트가 접근한다며 이는 priority inversion을 초래할 수 있다. 예를 들어 낮은 우선도 스레드가 높은 우선도 스레드를 막는 경우 이다. 그래서 보통 우선도의 스레드가 프로세서를 독점하고 낮은 우선도 스레드가 중요 부분을 들고 있다면 영구적인 priority inversion이 발생할 수 있다.
실시간 시스템의 상호 배제에 대해 일반적인 접근법은, non-preemptive critical sections(NCP)를 포함하거나, immediate and original priority ceiling protocols(IPCP and OPCP)를 포함한다. 실시간 시스템에 관련해서 상호 배제에 관련한 가장 중요한 점은 priority inversion(우선도 역전)에 대한 기준이다. 이러한 시스템은 기본적으로 안정성에 우선을 두기 때문에, 기능의 복잡도 또한 매우 중요하다. 효율적인 시스템은 performance overhead가 주안점이지만, secure system의 경우엔 은닉된 채널을 피하는 것이다.

![](/images/Scc/1.png)

위 사진은 4개의 다른 프로토콜을 비교한다. 각각 장단점이 존재한다. PIP의 경우 매우 높은 기능 복잡도를 가지고 있으며 blocking time이 높아 resource ordering이 사용되지 않는다면 deadlock 현상을 만들지만 간단한 것이 장점이다. NCP의 경우 가장 간단하지만 가장 긴 blocking time을 가지고 있다. IPCP의 경우 간단하지만 모든 자물쇠의 우선도를 미리 알고 있어야 한다. OPCP의 경우 가장 짧은 BLOCKING TIME을 가지고 있지만 PIP보다 더 복잡하며, 모든 자물쇠가 GLOBAL STATE를 알 수 있도록 유지해야한다. 이 경우 이 논문의 목적과는 맞지 않는데, 이는 covert channel을 만들고 sel4의 탈중앙화된 사용자 레벨 자원 관리와 호환되지 않기 때문이다. IPCP의 경우 커널이 critical section에 대한 지식 없이 완성될 수 있음을 다음 섹션에서 보여 줄 것이다. 

# MCS Scheduling Model
## Requirements
이 부분에서 mixed-criticality scheduling 모델을 설명할 것이며, 이는 seL4와 같은 높은 안정성 시스템에 적합하다. 모델은 다음 기준을 만족해야 한다.

### Capability-controlled enforcement of time limits :
Capabilities는 접근 권한에 대해서 생각할 수 있도록 도와준다. 이는 seL4와 같은 capability-based spatial access control of security-oritented system와 문제 없이 결합이 가능토록 한다.

### Policy Freedom : 
microkernel의 철학을 따라, 이 모델은 시스템들이 특정 리소스 관리 정책을 따르도록 강요하지 않는다. 이 모델은 넓은 범위의 scheduling policy, resource-sharing models, locking protocols를 지원한다.

### Efficient : 
모델은 가장 좋은 implementation을 가장 적은 overhead를 사용해야 한다. 예를 들어, 고성능 마이크로 커널의 빠른 메세지 전송 IPC와 호환되어야 한다.

### Temporal Isolation : 
시스템 설계자들이 시스템을 만들때 한 부분의 에러가 다른 시스템 부분의 에러와 연결되지 않도록 해야한다. 이는 공유 자원에도 적용된다.

모델은 가장 기본적인 커널 레벨에서 isolation을 제공하면서도 사용자 레벨에서 복잡한 스케줄 정책이 도입될 수 있도록 해야한다. 이 논문에서는 캐시와 가상 메모리를 가지고 있는 현대화된 멀티코어 하드웨어을 대상으로, 가장 비관적인 WCET의 기능을 exploit 하도록함.

## High-Level Concepts

정의에 따르면, priority(우선도)는 작동가능한 스레드에서 다음 가장 높은 우선도를 선택한다. MCS를 지원하기 위해서 우선도의 정의를 바꾸지 않지만 스레드가 runnable(작동가능한)하다는 의미를 바꾸려고한다. 이는 각 스레드에 사용되는 budget(한도)를 사용하여, 만약 스레드가 한도를 소진하였을 경우
작동 불가능한(non-runnable) 상태로 바꾼다. 우리는 static priority model를 사용하며(커널은 우선도를 마음대로 조정하지 않지만 시스템 콜을 통해서는 바뀔수 있음), 이를 유저 레벨에서 동적 우선도를 도입할 수 있도록하여 특정 스케줄 모델의 클래스만 제한하는 것 최대한 피하려고한다.

### Budgets and Scheduling contexts
Scheduling context(SC)의 가장 근간에는 시간 할당의 기본적인 추상화가  존재한다. SC는 object-cpability 시스템의 시간을 표현하며 이는 SC가 스레드나 주소  공간 또는 통신 종점(포트)와 같은 first-class에 해당함을 의미한다. SC는 'capability to a scheduling context object(scCap)이라고 표현할 수 있다.
scCap은 프로세서에 대한 접근 특권을 의미하고, 이는 capability to time(시간에 대한 능력)을 의미한다. 스레드가 작동하기 위해서는 scCap이 필요하며 이는 스레드가 소비할 수 있는 CPU 대역폭의 최대치를 의미한다.
실시간 시스템의 변할 수 있는 특징은 대역폭 제한은 특정 시간대에 도입되어야 한다는 점이다. 이를 도입하기 위해서 SC는 period(주기)를 T로 표현하며, budget(한도)를 C로 표현한다. 이 두 변수는 C <= T의 관계를 가지며 이는 SC가 주어진 주기(시간)내에서 소비할 수 있는 최대한의 시간이 된다. 그래서 U (utilization) 가동률률 U = C/T로 표현하며 이는 최대 CPU 가동률이 된다. SC는 많은 시스템에 사용되는 시간 조각의 일반화된 개념이라고 볼 수 있다.
멀티 코어 시스템에서는 SC가 특정 코어에 대한 접근 권한을 의미한다. load balancing과 같은 core migration는 커널이 아닌 사용자 레벨에서 도입되어야할 정책이다. 스레드는 보유한 SC를 다른 코어의 SC로 교체함으로써 이동이 완료된다.
한도를 정하는 것은 admission control(진입 제어)이며 이는 적절한 권한이 필요하다. 각 코어에 주어진 총 시간은 코어당 scheduling-control capability(sched_control)로 표현한다.

### Priorities
Fiasco.OC는 L4 microkernel에 스케줄링을 도입하였다. 이는 개념적으로 우리와 비슷하지만, Fiasco.OC의 SC는 capability-controlled가 아니다. 또한 Fiasco.OC는 priority(우선도)를 SC의 속성으로 사용한다. 반대로 우리는 priority가 스레드의 속성이 된다. 이의 장점은 priority와 SC가 직교적인 관계를 띄가 된다.
Fiasco.OC 처럼 우리는 우선도를 static attribute(고정된 속성)으로 사용한다. (다만, 사용자 레벨에서 시스템 콜을 사용하여 변경시킬 수는 있다.) 그 이유로는 첫번째로 고정 우선도 스케줄링은 이미 산업계에 많이 친숙하고 널리 사용되는 개념이기 때문이다(그래서 인지 EDF는 종종 눈치를 받곤 한다). 또한 seL4에 사용된 모델들에 잘 적용되며 시간 조각 속성을 scCap을 대신하여 교체할 수 있다. 또한 이 모델의 한개의 우선도를 사용하여 EDF의 동적 우선도를 사용할 수 있다(낮은 오버헤드로도 가능). 하지만 반대는 참이 되지 않는다. EDF의 동적 우선도를 고정 우선도로 매핑하는것은 단순하지 않으며 이는 높은 오버헤드를 발생시킨다. 커널이 고정 우선도 스케줄과 같은 특정 정책을 도입한다면 우리의 접근방식은 다른 정책들을 효율적으로 도입할 자유를 보장한다. 
마지막 이유로는 고정 우선도가 overcommited system에 대한 행동 방식에 대한 추론할 수 있는 능력을 제공한다. Overcommitting은 모든 SC의 가동률의 합이 스케줄 한계점 이상이 되는 것을 의미하는데, 이는 critical hard 실시간 스레드에는 큰 시간 버퍼가 필요하기 때문이다. 또한 커널이 policy-free하기 위해 중요하다. 특정 시스템의 정책은 overcommitment의 정도와 특징에 따라 달려있다. 예를 들어 high 스레드의 RMS 스케줄 능력을 69퍼센트로 제한하면서도 low 스레드는 overcommit 할 수 있게 하여 overcommitment의 정도는 hard RT와 soft RT와 best-effort 스레드에 따라 달라질 수 있다. 그런 정책은 커널 보다 사용자 레벨에서 도입되어야 할 것이다. 